# 基础知识

第一篇教程先教一些基础知识, 补一下

## [科普] 计算机

让我们从 CPU 的角度简单了解一下 计算机如何处理计算.

CPU 由程序指导如何处理计算. 程序由一系列指令 (*instruction*) 组成, 处理器每次从程序中读出一个指令然后执行, 然后读取下一个指令. 处理器中具有一些读写超快的内置存储空间, 称为寄存器. 寄存器中保存了一些处理器当前正在使用和运算产生的数据. 

寄存器的空间很小, 更多的数据存储在 **内存** 中. 处理器可以直接读取内存(相比磁盘等外部存储器是直接的), 通过 **内存地址** , 处理器可以直接把内存特定位置的数据读取到寄存器或把寄存器的数据写入到内存. 

单条指令可以让CPU做的事微小, 比如:从内存中读写数据, 或者对两个寄存器的数相加然后结果写到另一个寄存器中, 再或者根据一个寄存器中的值决定是否将下一个指令读取的位置设置为特定值. 但是CPU运行很快, 一个 GHz 级的处理器, 可以执行将近十亿条指令. CPU 能识别的指令事固定的, 并且每条指令都由数字编码, CPU 能够识别的指令的集合一般被称为 **机器语言**.

> 在冯诺依曼架构的机器中, 程序与数据一样存放在内存中, 现在通用计算机都是以此为原型, 在此之前的计算机多是程序存放在另外特定的存储器上, 或是通过其他方式表示程序.

## [科普] 编程语言

直接通过机器语言编写程序是困难的, 从一个二进制数判断这是什么指令, 和它的参数并不容易, 所以人们给指令和寄存器起了一些适合人类阅读的助记符, 使用一个更便捷的方式表示指令, 这就是汇编语言. 下面是几个汇编实例(由C语言程序生成)

```c
int max(int a, int b) {
    return a > b ? a : b;
}
```

```asm!
#X86-64汇编
max(int, int):
        cmp     edi, esi
        mov     eax, esi
        cmovge  eax, edi
        ret 
```

```asm!
#ARMv7汇编
max(int, int):
        cmp     r0, r1
        movle   r0, r1
        bx      lr
```

```asm!
#RISC-V 汇编
max(int, int):
        bge     a0,a1,.L2
        mv      a0,a1
.L2:
        ret
```

汇编程序虽然更容易阅读了, 但是依旧是底层的, 对于编写大型代码仍旧是具有挑战性的. 所以后续建立了各种包含了更多抽象, 隐藏了更多繁琐细节的编程语言. 下面是一个C语言示例. 

```C
#include <stdio.h>
int main() {
    puts("HelloWorld");
    return 0;
}
```

但是不论是汇编, 还是后来的其他什么语言计算机都无法直接读取并运行, 所以这些语言在执行时必然存在一个将这些文本转换为底层二进制指令的过程. 这个过程称作什么取决于编程语言的设计, 可能叫做汇编, 编译, 解释 etc.

## C 语言历史

C 语言属于比较早期的编程语言, 但是影响巨大, 部分现代编程语言的语法受到 C 的语法综合影响, 以此为标准，它们可以被称为 C 系语言 <sub> <small> ~~shidi~~ </small> </sub>.

C 语言第一份可以视作规范的文件是1978年的《The C Programming Language》作者是 *Brian *K*ernighan* 和 *Dennis *R*itchie*，因此这本书被称为 **K&R** ，由此书所确定的C语言规范被称为 **K&R C**. 但在此之前 C 语言就已经存在于贝尔实验室用于移植和开发 *UNIX 操作系统*.

之后的 C 语言被美国标准化协会 (ANSI) 立项标准化, 1989年提出了第一份C语言的标准文档, 这个标准被国际标准化协会 (ISO) 采纳. 之后的C语言标准化工作又  `ISO/IEC JTC 1/SC 22/WG 14` (ISO下属的一个委员会) 负责.

> `ISO/IEC JTC1/SC 22/WG 14` 的意义是 `ISO/IEC JTC1 (Joint Technical Committee 1) / SC22 (Subcommittee 22) / WG14` (Working Group 14)`

我们使用年份称呼C语言的标准, 比如第一份标准是 *C89*, 之后还有 *C99*, *C11*, *C17*, *C23*. 由于历史原因, `ANSI C` 有时候指代的是 *C89*. 

本系列教程根据算法竞赛的主要讲解 *C11* 的特性, 在其之后的标准特性都会有标注, 赛时的编译器不一定支持. 早期的C语言(尤其是 K&R C) 与现在的C语言语法变化很大, 我们不讲解早期语法, 但是会注意到 *C89* 和现在的区别, 因为学校考试时可能只认 C89.

另外说明 C 语言和 C++ 是高度相关的两门语言, 它们的标准都由 *ISO* 维护, 都在 `JTC1/SC 22` 子委员会, 两边的工作组都有保障两门语言兼容性的专门研究组, 所以大部分 C语言代码 都可以在 C++ 编译器上编译通过, 但是它们实际上仍是两门语言, 实际上语法上也存在各种不兼容的地方, 所以严格意义上 C 不是 C++ 子集.

## 略微教一下命令行

命令行界面, 是一种简单的程序交互界面. 命令行种类有很多, 这里仅讲解一下通用的概念. 使用的示例是 Winodws 上的 PowerShell. 使用 `Win+X` 然后选择终端即可打开.

![连接在Windows Terminal上的PowerShell](https://hackmd.io/_uploads/Symmkov5C.png)

### 路径

路径用于指定文件系统中的目录和文件, 路径的具体格式取决于操作系统, Linux维护单根的目录树并使用 `/` 作为目录分隔符, 而 `Windows` 操作系统必须将每个文件系统分配到一个盘符才能引用, 使用 `\` 作为目录分隔符. 上图中 `C:\User\LL06p` 中 `C:` 就是盘符.

路径由两种形式, 从根路径开始指定的 **绝对路径**, 和不带有根目录的 **相对路径**. 

相对路径的具体指向取决于它的参考的目录, 一般情况是 **当前工作目录**. 

几个特殊的目录

- `.` 指代当前目录
- `..` 当前目录的父目录
- `~` 家目录(当前用户的用户目录, 比如上文的 `C:\User\LL06p`)

### 命令

大多数命令行环境的命令格式都是 `命令 命令行参数` 的格式, 第一个单词指定要执行的程序, 可以可执行文件的相对路径或绝对路径. 

下面是两个程序的实例, `pwd` 可以显示当前工作路径, `ls` 指定路径下的文件和目录, 这里没有指定参数, 默认显示当前路径下的文件和目录.

![两个程序实例](https://hackmd.io/_uploads/ry7xlnPqR.png)

命令行参数是以空格分隔的单词, 这些单词会传递给程序. 可以使用 `"` 包围使得一个命令行参数包含空格.

![使用了命令行参数的命令](https://hackmd.io/_uploads/SyUWZ2P5R.png)

命令行参数的解析方式是完全由程序决定的, 但是统一环境下大多数程序都遵守一个 *选项* 的风格. (环境提供了解析的工具, 所以这样做方便)

比如Linux下常见的风格: 短横杠 `-` 加一个字符或数字表示一个短选项（Unix 风格）, 双横杠 `--` 加一个单词表示一个长选项（GNU 风格）. 短选项的附带参数与选项空一格, 长选项的参数与选项用 `=` 连接起来. 短选项可以公用一个 `-` (`-abd`).

### 环境变量

环境变量是在进程初始化时传入的一些变量, 与命令行参数性质类似, 不过过用于描述操作系统的环境信息.

比如环境变量 `PATH` 用于指定命令行解释器在哪里指定了一些存放常用程序的程序的位置, 当前目录下既没有这个命令, 指定的也不是绝对目录, 但是命令可以执行的原因就是在 `PATH` 路径列表里找到了这个程序 (上文的ls和pwd 并不是这种情况, 它们是内置在PowerShell中的命令的别名, 为了是与Linux环境上的Shell行为类似).

可以在Windows搜索中找到 `编辑系统环境变量 > 环境变量` 查看当前系统的所有的环境变量

![图片](https://hackmd.io/_uploads/B1CCX3v5A.png)

### 标准流文件

通过命令行启动程序时, 一般会同时启用 *标准输入*, *标准输出*, *标准错误* 三个文件 (硬盘上那个 "文件"). 这三个文件会关联到终端的输入和输出, 但是也可以通过重定向等方式将标准流指向其他地方, 比如可以将一个程序的 *标准输出* 和另一个程序的 *标准输入* 链接, 或者将程序 *标准输出* 定位到硬盘上的常规文件. 这在后续会逐渐了解, 不过多阐述.

### 返回代码

进程结束时, 进程会向操作系统返回一个代码, 这个代码一般情况情况下用于表明程序是否执行成功. 在 *PowerShell* 和 *Bash* 中, 可以使用终端变量 `?` 获取上一个在这个终端启动的程序的返回代码.

![返回代码](https://hackmd.io/_uploads/SkXpO2vqR.png)

这里返回的 `True` 表示正常执行, 这里的返回值经过了PowerShell的处理, 程序内部返回 `0` 表示正常执行.

## 使用和安装编译器和IDE

上文中提到了计算机不能理解C代码, 需要将C代码翻译成可执行的机器码才能够作为程序执行. 这里需要的一种工具是 **编译器**, 一种进行将高级语言翻译为机器码 (或者其他什么低级表示形式) 的程序. 

上文也提到了现在的C语言由 *ISO* 维护标准, 但是 ISO 并不提供编译器, 它们维护的只是C语言 语法和语义的 **标准**. 至于C语言编译器或者说C语言的 **实现**, 由其他组织提供.

现在使用最多的C/C++编译器是 *GNU* 的 *gcc*, *LLVM* 的 *clang*, 和 *微软* 的 *MSVC*. 算法竞赛赛场上常用的是 gcc. 在我们学校的C语言程序设计课程使用的是 Visual Studio 6.0 所带的 *MSVC 6.0*. 

### 安装和使用 gcc

本文所使用的编译器是 `gcc`, 但它的并不是为 `Windows` 设计的, 所以需要一些兼容环境, 这里我们使用 `msys2`.

[msys2](https://www.msys2.org/)

安装官网上的步骤安装即可. 注意记住安装的路径.


想要在其他终端使用 `msys2` 中的 gcc 需要配置环境变量, 将 `安装目录\ucrt64\bin` 路径放入 PATH 环境变量中, 即可.

现在随便打开一个文件夹, 建一个名为 `HelloWorld.c` 的文件. 使用记事本打开, 将如下代码输入进去.

```c
#include <stdio.h>
int main() {
    printf("HelloWorld\n");
    return 0;
}
```

右键文件管理器的空白处, `在终端中打开`, 可以以这个路径为当前工作目录打开一个终端.

> 如果没有这个选项, 可以通过 `Win+X ; 终端` 的方式打开一个终端, 然后使用 `cd` 命令切换过去.

运行如下命令

```bash
gcc HelloWorld.c -o hello
```
    
可以看到多出来一个名为 `hello.exe` 的可执行程序, 通过命令行运行

```bash!
./hello.exe
```
![输出](https://hackmd.io/_uploads/BJwHbaPqR.png)

说明环境正常.

### 安装IDE

IDE 集成开发环境, 一种集合了文本编辑器, 编译器, 调试器等工具的图形界面环境. 是一种方便的开发工具. 

本文以 `Dev-C++` 为例, 虽然不好用, 但是 是部分比赛所要求的开发环境.这里列举一些现代的IDE 感兴趣的可以尝试.

- [Microsoft Visual Studio](https://visualstudio.microsoft.com/zh-hans/) : 需要额外安装 `C++桌面开发` 工作负荷
- [XCode](https://developer.apple.com/xcode/) : MacOS 上的 IDE.
- [JetBrains CLion](https://www.jetbrains.com/clion/) :跨平台工具, 不自带工具链, 需要另外下载并配置, 项目配置需要 `CMake`
- [Microsoft Visual Studio Code](https://code.visualstudio.com/) : 定位是文本编辑器, 通过扩展组件可以调用编译器和调试器.
- [Code::Blocks](https://www.codeblocks.org/) : 不算新的工具, 但是跨平台.

[Dev-C++](https://sourceforge.net/projects/orwelldevcpp/files/latest/download), 如果不配置安装位置, 可以无脑下一步.

安装后的界面:

![DevC++](https://hackmd.io/_uploads/SkCeKTwqC.png)

`Ctrl+N` 新建文件, 把上文的HelloWorld复制下来, `Ctrl+S` 保存. 点击 `编译并运行` 即可.

![代码](https://hackmd.io/_uploads/ryeiiav5A.png)

![执行](https://hackmd.io/_uploads/r1DKt6P5R.png)

![运行结果](https://hackmd.io/_uploads/SknFiaw9A.png)
    
### 

## 参考文献

- C Primer Plus