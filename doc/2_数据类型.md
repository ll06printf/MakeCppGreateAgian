# 2课时:数据类型

> 所有 `quote` 块内的内容都是可选的.

## 前情回顾与补充

上一节中我们了解计算机编程的基础概念, 安装了 C/C++ 的基础开发环境, 并通过 *HelloWorld* 程序检测了环境的可用性.

现在我们再来回看一下 *HelloWorld* 程序.

```c
#include <stdio.h>

int main() {
    printf("HelloWorld\n");
    return 0;
}
```

这个程序中第一行的 `#include <stdio.h>` 是一条预处理命令, 预处理的作用一般是进行一些 **文本性质的替换** . 此处的 `#include` 命令的作用是将后面指定的这个文件插入这个位置. 文件 `stdio.h` 是一个 **C标准库** 提供的一个头文件, 它提供了文件操作和窄字符输入输出的方法.

从第三行到第六行, **定义** 了一个名字为 `main` 的函数. 在常规的 C/C++ 程序中,  `main` 是用户代码的 **入口**, 程序会从 `main` 函数开始执行.

> [!Note] C/C++ 的独立实现
> C/C++ 的标准规定, 实现分为 **有宿主的** *Hosted* 和 **独立** *Freestanding* 的两种. 其中这里 **宿主** 指操作系统. 具有操作系统的环境标准要求编译器提供更多特性, 而对于 **独立实现** (常见于编写操作系统自身或嵌入式编程), 标准要求放宽很多, 基本上只要求满足核心语言特性即可. 比如 独立实现 中标准并不要求程序从 `main` 函数开始.

> [!Note] C 和 C++ 在 main 函数上的差异
> C 和 C++ 在 main 函数在语义的定义上有些许差异, 其中最明显的是 C++ 中不允许用户代码对 `main` 函数有任何指明使用 (比如递归), 而 C 没有这些限制.

程序的第四行和第五行是两条 **语句**, 语句以分号`;`作为结尾 (有例外, `{}`). 

上面的 `printf("HelloWorld\n");` 是一条表达式语句. 这里 `printf` 是一个由 `stdio.h` 提供的一个函数, 意思是 *print format* 格式化打印, 功能是将给出的 **数据** 以想要的形式输出到 **标准输出** (标准输出的概念请查阅第一节) . 括号内部是它的的 **实参列表**, 这里一个参数 `"HelloWorld\n"` 指明了要打印的内容. `\n` 是转义序列, 用来代指由于技术等原因无法直接写在源代码文件的符号, 比如 `\n` 指代换行符. 表达式 是本课程的重点之一, 后面会再次详细介绍.

下面的 `return 0;` 是一种跳转语句, 它将终止当前函数并返回指定值（如果存在）给调用者。 对于 `main` 函数来说, 返回意味着程序结束, 返回值就是这个进程的返回代码.

## 数据类型

本节介绍程序设计中基础数据类型和它们在 C/C++ 中的表示方式.

在这之前, 先来了解一下 C/C++ 的变量声明语法:

最简单的形式如下, 写出变量的类型加上变量的名称即可.

```c
类型名 变量名;
int  a;
```

更加一般的形式如下:

```c
类型名 声明列表;
int a, b, c;
```

其中声明列表是一个由 `,` 分隔的声明项. 声明项可以包含一个简单地只包含一个标识符 (比如 `int a;` 中的 `a`) , 也可以包含各种修饰用以声明复杂的类型 (后续介绍) , 和一个可选的指定变量初始值的初始化器 (比如 `int a=1;`) .

```c
// 以下是几个示例, 其中 int 是一个类型的名字.
int a; // 声明了一个名字为 a 类型为 int 的变量
int a, b, c; // a, b, c 三个变量, 类型都为 int
int a=1, b=2, c; // 声明了 a, b, c三个变量, 其中 a, b 指定了初始值.
int a, b = 1; // 这个形式只有 b 被赋予了初始值. 但是有时候会造成 a 也被赋了初始值的误解
```

这里再简要说明一下变量名的要求, 一般而言:

- 变量名只能包含 **大小写字母**, **数字**, **下划线** `_`.
- 变量名不能以数字开头
- 变量名不能与 **关键字** (被 C/C++ 本身占用的在特定上下文具有语法功能的文字) 和 **其它保留字** 冲突.


另外以一个下划线加大写字母开头的标识符, 全局空间单下划线开头的标识符, 和包含双下划线的标识符被语言 **保留**, 为防止冲突，您不应在声明时使用它们.

> [!Note]
> 您可以在 Clang 编译器使用 `-Wreserved-identifier` 选项防止定义保留标识符

标准支持中文和其它 Unicode 标识符，但由于编译器支持等原因，不推荐您在低版本的编译器中使用非 ASCII 的标识符，详细的标识符定义参考 [标识符](https://zh.cppreference.com/w/cpp/language/identifiers).


### 布尔类型

**布尔值** (*boolean*) 是布尔代数中的数值类型, 其只有 **真** 和 **假** 两种取值. 以布尔代数为主的数理逻辑会在离散数学课上有详细介绍, 这里简单介绍一下布尔代数的基本运算:

- **与**, 也称 **合取**, 二元运算, 当作为操作数的两个值都为真时, 结果才为真, 否则为假.
- **或**, 也称 **析取**, 二元运算, 当作为操作数的两个值都为假时, 结果才为假, 否则为真.
- **非**, 一元运算, 操作数为真, 结果为假; 操作数为假, 结果为真.

C在 C99 之前不支持布尔类型作为基本类型, 在 C99 是加入了该类型名字为 `_Bool` 看起来和其他类型的名字相当不同, 这个做的原因是保护 "现有" 代码.

在 C++ 的语法中 `bool` 是布尔类型的类型名, 并且配套两个字面量 `true` 表示真, `false` 表示假. 

```C++
bool state1 = false;
```

> [!note] 额外语法支持头文件
> C的演化策略是保守的, 在添加新关键字的时候会使用被保留的标识符作为关键字, 避免影响现有代码, 同时它们提供了额外语法支持的头文件, 包含 `#include` 该类头文件之后, 可以使用更便捷的语法. 比如在 包含 `stdbool.h` 之后, 可以使用 `bool` 作为布尔类型类型名, `true` , `false` 作为 `bool` 类型的字面量.

> [!tips] `bool` 的长度
> 虽然 `bool` 类型在技术上只需要 1 位存储, 但是在绝大多数平台上`bool` 类型的长度至少为 1 字节（sizeof(bool) > 0），如果要节省空间，请使用 `bitset`

下面介绍C中用来处理布尔运算， 或者说位运算的运算符。

> 这里暂时不区分 **逻辑运算** 和 **位运算** 在C中的区别.

```c++
// && 与运算
false && true; // 结果是 false
// 这个结果可以用来给 变量 **赋值**。
bool cond;
cond = false && true; // 这里 = 的意思是将 左边的变量的值 设置为右边给出的值。
// || 或运算
false || true; // 结果是 true
// ! 非运算
!true; // 结果是 false
```

<!--

```C++
// || 或运算
bool cond1 = false;
bool cond2 = true;
cond1 || cond2; // 结果是 true
```

```C++
// ! 非运算
bool cond = true;
!cond; // 结果是 false
```

-->

除了这几种基础的布尔运算外, C 还提供了异或运算, 这是一种二元运算, 只有当两个操作数不同时, 结果为真.

```C++
bool cond1 = true;
bool cond2 = false;
cond ^ cond2; // 结果为 false
```

在大多数现代的电子计算机中, **位(bit)** 是最基本的操作单元, 它有两种状态, 与 布尔值 相对应. 但是布尔类型并不是 C提供的用于直接操作位的组件, 位处理会在后面的章节介绍.

### 整数类型

#### 位置计数简述

在介绍整数之前，我们先来复习 **位置计数系统** 相关的概念. 

> 补充资料: [位置计数系统](https://zh.wikipedia.org/wiki/%E8%AE%B0%E6%95%B0%E7%B3%BB%E7%BB%9F)

> 这里假设高中数学教过计数系统, 不过多介绍.

先来回顾一下我们熟悉的 **十进制**, 它也是一种位置计数系统, 它有 0 到 9 十个符号, 可以用这10个符号组成的串表示所有的整数. 我们之所以称之为 **位置计数系统**, 是因为每一个符号代表的数值大小取决于它的位置, 或者说每一位的权重不同, 比如说 $123$. 从低位（右端为低）到高位的, 第1位的权重为 1 ($10^0$), 第2位, 权重为 $10^1$, 以此类推, 第 $pos$ 位的权重, 为 $10^{pos-1}$. 这里每一个权重都是 10 的幂, 所以这种计数方式称之为 **十进制**. 其中这个 $10$ 称为 **基数**.

$$
123 = 1 \times 10 ^ 2 + 2 \times 10 ^ 1 + 3 * 10^ 0
$$

冯·诺伊曼在 EDVAC 设计报告中提出了使用二进制系统用于算数的构想 ，以此相承，现代计算机架构使用二进制作为算数系统。 

虽然理论上 **二进制** 也可以表示所有的整数, 但是计算机的硬件资源是有限的, 而且长度可变的资源比较难于管理和操作. 所以我们计算机中一般将整数数据使用固定数量的位（2 的幂次）表示(比如 8 位, 16 位, 32位). 

但是固定位数的整数数据在运算的时候难免出现位数不够的情况, 比如在 最高位 进行加法时发生了进位. 这种情况称为 **溢出**. 溢出时的计算行为将在下一节介绍.

#### 有符号数的表示

> 资料: [有符号数的处理](https://zh.wikipedia.org/zh-cn/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86)

现在来讨论一下计算机底层如何表示 负数.

我们一般讨论三种解决方案:

- **原码** : 基于一种朴素的添加正负号的方案, 即将整数最高的一位作为 **符号位**, 当这一位为 1 时 这就是负数. 其他位依旧按照原有的意义编码绝对值.
- **反码** : 也叫一补码 （**one's complement**）， 反码与原码的区别在于, 当数为负时, 绝对值部分每位都与原码相反, 相当于最高位的权重变为了 $-(2^{len-1}-1)$, 其中 $len$ 表示有符号数的长度
- **补码** : 也叫二补码 （**two's complement） 补码与原码的区别是, 当数为负时, 绝对值部分的每一位都与原码相反, 在此基础上加一. 相当于最高位权重变为了 $-(2^{len-1})$.

这里不展开讨论, 直接说结果, **补码** 是当今使用最广的有符号数编码方案.

它的优势在于没有重复的0表示, 和在忽略进位的情况下, 有符号与无符号数的加法和乘法在 **位模式的意义上** 相同. 

更多的资料可以参考 *深入理解计算机系统, 第二章第二节*, 这里提供了严谨的数学解释.

#### 变量声明

C提供了多种长度的整数类型可以选择, 但是实际上 C标准并未严格要求各种类型应该使用多少位, 标准把选择的权力交给了编译器的实现者.

- `short int`
- `int`
- `long int`
- `long long int`

上述为 C提供的几种整数类型的名字, `int` 为 整数 `integer` 的缩写. 除了只有一个 `int` 关键字的那个类型, 其他几个类型中的 `int` 都可以省略.

在常见环境下. 这几个类型的长度配置如下:

- `short` 16位
- `int` 32位
- `long` 32位或64位
- `long long` 64位

> [!Note] 不推荐使用 `long int`，`long`在 Unix（大部分是LP64数据模型，64位） 和 Windows（ LLP64数据模型，32位）下的长度不一致。
> 如果要使用确切位数的数据类型，请使用 cstdint 中的定宽整数类型

这些默认是 **有符号** (可以是负数) 的类型, 对于无符号的整数需要加上 `unsigned` 作为前缀.

```c++
short s;
int i;
unsigned ui; // unsigned int 类型的变量
long l;
signed si; // 和 int 同义
```

为了指定变量的初始值, 我们可能需要, 在代码中便是一些表示固定值的方法, 即 **字面量**.

```c++
short s = 114;
int i = 514;
```

整数的字面量可以直接像这样写十进制数. 也可以使用其他类型的字面量.

```C++
short s = 0114; // 以 0 开头的 八进制字面量, 这个数的大小是76
int i = 0x114a; // 以 0x 开头是 十六进制字面量, 十六进制中需要 16 中符号, 数字不够用所以使用 a-f 作为补充.
long l = 0b0011'0011; 
// 以0b 开头的是 二进制字面量. 另外这里使用数位分隔符 ' , 他没有实际意义, 仅用作分隔数位, 使得表示更加清晰.
// 二进制字面量和数位分隔符加入 C++ 和 C 的标准分别是 C++14 和 C23, 在竞赛中不一定能使用.
```

另外字面量是由类型的概念的, 比如以上所有的字面量都是 `int` 类型, 通过添加不同后缀可以改变字面量的类型.

```c++
unsigned u = 123u; // 无符号后缀 u
long l = 123L; // l 和 L 都是可接受的, 为了防止 l 与 1 混淆, 一般用大写
unsigned long ul = 123ul; // 无符号和长整型整合
long long ago = 123LL;
```

这里提一个 C++ 的语法特性 `auto` 类型占位符. 这是 C++11 添加的特性, 当将其用作类型名称时, 编译器可以自动从上下文推导此处该填入何种类型, 特别地, 在变量声明时它会根据变量的初始值类型推断变量的类型.

```C++
auto u = 1234u;
auto ll = 123ll;
```

#### 运算

C为整数类型提供了常见 `+`, `-`, `*` (乘), `/` (除), `%` (模, 取余) 运算. 

```c++
123+321; 
auto var = 123+321; // 一个 int 类型的变量
```

这里首先说明一下 `+` 和 `*` 的溢出行为. C/C++ 标准对有符无符号整数的要求不同:

- 对于无符号整数: 标准允许，要求结果相当于模 $2^n$ , 这相当于直接抛弃了溢出的部分.
- 对于有符号整数: 标准说明 **行为未定义**, 但是对于一般情况, 因为采用补码表示整数, 会在位模式上采取与无符号数相同的行为. 这会引起 **回绕** 现象的发生.

在整数运算中，为了避免溢出，您可以使用更长的整数类型来存储中间结果，如 `int` 可以使用 `long long`。

```c++
int c = 1ll * a * b % mod;
```

> [!note] `__int128`
> `__int128` 是 GCC 扩展，为 128 位的整数，可以用于 `long long` 溢出的运算，在此情况下可以省去编写 2 个 `long long` 的结构体及其运算，但由于它是 GCC 的扩展而非标准的一部分，输入输出流、`abs` 函数 等未对其提供支持，如若使用请小心使用并进行测试。

下面程序演示了简单演示了溢出时表达式的求值结果:

```C++
#include <stdio.h>
#include <limits.h>

int main() {
    unsigned uInt = UINT_MAX;
    int sInt = INT_MAX;
    
    printf("The max number of unsigned int is: %u(%#x)\n", uInt, uInt);
    printf("The max number of int is: %d(%#x)\n", sInt, sInt);
    printf("The next number of unsigned int is: %u(%#x)\n", uInt+1, uInt+1);
    printf("The next number of int is: %d(%#x)\n", sInt+1, sInt+1);
}
```

下面是一种可能的输出:

```txt
The max number of unsigned int is: 4294967295(0xffffffff)
The max number of int is: 2147483647(0x7fffffff)
The next number of unsigned int is: 0(0)
The next number of int is: -2147483648(0x80000000)
```

接下来说明一下 `/` 除法和 `%` 取余, 这两个运算符作用在整数上会得到整数. 

对于可整除的情况 `/` 的结果显而易见, 对于不可整除的情况, 结果会被舍入到一个整数, 至于舍入的方向, 过去是由 **实现定义** 的 <!--note:这里叙述不准确--> , 但是从 C99 开始, 标准明确规定, **向零舍入**, 相当于直接去掉了小数部分.

```c++
6 / 3; // 结果为 2;
7 / 3; // 结果为 2;
-7 / 3; // 结果为 -2;
```

`%` 取余在正数上的行为不需要多说, 其在负数上进行取模的结果受到 `/` 舍入方向的影响, 因为标准规定 `(a/b)*b + a%b` 的结果与 `a` 相等. 如果 `/` 选择趋零截断, 那么 `a%b` 的结果的正负将由被除数 `a` 的符号决定, 绝对值相当于 `a` 和 `b` 绝对值进行取模, 这里不进行详细的推导.

```c++
5 % 3; // 结果为 2
-5 % 3; // 结果为 -2
-5 % -3; // 结果为 -2
5 % -3; // 结果为 2
```

另外 `/` , `%` , 除零都是 **未定义行为**, 对于多数环境, 这会引起一个硬件错误, 最终导致程序中止.

> [!note] 遵从性 和 未定义行为
> C是一门 **实现者友好** (易于实现) 的语言, 标准很多在很多处都给编译器的实现留下选择的空间, 把一些处理的细节交给编译器的实现者选择以获得最佳的效率.
> C和C++将不在标准中定义的行为归类为数个种类, 最常见的为以下两类:
> - **未定义行为** : 程序可以采取任何行为, 且实现者不需要说明.
> - **实现定义行为** : 程序应采取某种特定的行为, 编译器实现者应该将行为明确写在编译器文档中.
>
> **严格遵从** 标准的程序不应该依赖于 **任何** 未有标准保障的行为, 但是这种强度的遵从性在很大程度上是 **收益甚微** 的 (这种程序写起来非常困难), 我们只需保障我们的程序被主流的实现所接受即可. 但请尽量不依赖于 **未定义行为** 等实现完全不保证其行为的特性. 
> 
> 当程序出现未定义行为时，会阻碍编译器优化，且在开启高优化等级编译时会与预期行为不一致（如果您发现编译器在高优化等级和低优化等级中的行为不一致，可能就是由于此原因）。尽量防止出现未定义行为可以给编译器提供足够的保证以进行优化。
> 
> 为尽量阻止您的程序里出现未定义行为，您可以在编译时开启所有警告（-Wall）并在调试时启用 UB sanitizer （-fsanitize=undefined），编译器和 sanitizer 会帮助您检出明显和可检出的错误。 

#### 字符类型

对于 C/C++ 来说, 字符由整数所编码, 不具有更多特性. 字符类型使用 `char` 作为类型名. 字符具体是 有符号 或者 无符号 的整数, 标准留给实现决定. 但是可用 `signed` 和 `unsigned` 关键字修饰的 `char` 明确指定是否有符号.

> [!note] `char` 是独立的类型
> 在标准语义上来说, `char` 既不是 `unsigned char` 也不是 `signed char`, 是一种独立的类型, 但是与其中一个具有相同的表示和对齐.

计算机使用数字编码字符, C提供了字符字面量来表示字符，C中的字符字面量是整数类型，对应其编码值，C++ 中的字符字面量是字符类型，在整数环境会隐式转换到整数类型.

```c++
'a';
```

上述是一个字符字面量, 它表示字符 `a` 在 ASCII 码表中的编码值. 值得一提的是, 这种表示在 C和 C++ 中的类型不同, 在 C中字符字面量的类型是 `int` (但这不影响你把一个字符字面量赋给一个 `char` 类型的变量) , 而在C++中是 `char`.

ASCII 码表具有 128 个码位, 是一种 7 位的编码, 而对于绝大多数环境 `char` 的长度位 8 位. 所以在表示 ASCII 字符时, 最高位一般为 `0`. 这使得如果 `char` 是一个有符号整数, 它在编码 ASCII 字符时 **一定是正数**. 这也意味着, 在某些兼容于 ASCII码表的 **变长编码** 的编码格式中, 一个非 ASCII 码位一定以一个负值开头. 中文编码常用的字符集 *GBK*, 和 *UTF-8* 都是这样的字符集.

ASCII 字符中包含了一些不能直接输入在源代码或者输入在源代码中会引起混乱的字符. 比如换行符等. 这些字符使用 **转义序列** 表示. **转义序列** 是一个 `\` 开头的几个字符. 换行符用转义序列表示为 `\n`. 另外一下为几种常见的转义序列:

- `\n` 换行（**n**ew line）
- `\r` 回车（carriage **r**eturn）
- `\t` 制表符（horizontal **t**ab）
- `\v` 垂直制表符（**v**ertical tab）
- `\b` 退格符（**b**ackspace）
- `\a` 响铃（**a**udible bell）
- `\0nn` 八进制转义, 表示指定八进制数对应码位的字符
- `\xnn` 十六进制转义, 表示指定十六进制数对应码位对应的字符
- `\'` 单引号
- `\"` 双引号
- `\?` 问号
- `\\` 反斜杠

参考资料: [转义序列](https://zh.cppreference.com/w/cpp/language/escape)

> [!note] 这些转义序列表示的字符的由来 
> 前几个看来名字很奇怪的字符来自于电传打字机用作计算机终端的时代. 换行表示将字锤对准下一行, 回车表示将字锤移动到行首. 制表符将字锤移动到下一个制表位, 方便对齐, 现代键盘上的 `Tab` 键实际上即是制表位的意思. 垂直制表符, 与制表符类似.
> 这些字符在现代终端上是否起作用取决于终端环境.
> 再往下的单引号, 双引号, 问号被列为需要转义的字符是因为区分歧义和历史兼容（`\?`）.

这里顺便介绍另一种和 字符 有关的字面量, **字符串字面量**. 它表示由一系列字符组成的字符串. 对于 C来说, 它是一个由 空字符 (编码值为0) 的字符结尾的一个 **字符串数组** (数组的概念将在后续的几节课中介绍).

```c++
"hello";
```

#### 练习

##### 练习前的补充知识

这里为了更好的进行练习, 说明一下如何从标准输入输出交换数据.

前面已经看到, 向标准输出写入数据我们使用了 `<stdio.h>` 里的 `printf`, 也简单介绍了这个函数的含义. 接下来详细了解一下这个函数的用法.

`printf` 函数的第一个参数是一个指定输出格式的字符串. 其中在字符串中使用 `%` 开头的格式化指示可以将一个数据按照指定的格式替换到这个位置, 数据由随后的参数给出.

```c
printf("a integer : %d", 123);
```

这里 `%d` 指代 `int` 型的有符号整数. 另外常见的格式化符如下:

- `%u` 无符号整数
- `%x` 无符号整数, 但是十六进制格式输出
- `%o` 无符号整数, 但是八进制输出
- `%c` 一个字符
- `%s` 一个 C 风格字符串
- `%%` 表示一个百分号

上面有符号整数和无符号整数可以使用 `hh`, `h`, `l`, `ll` 修饰表示不同长度的整数, 依次对应 `char`, `short`, `long`, `long long`.

```c
printf("%lu", 123ul);
printf("%x", 123u);
printf("%d,%d", 1, 2);
```

格式化字符串中的格式化指令中指定的类型必须于后续参数中指定的匹配.

接下来了解一下从标准输入读取格式化的数据, 使用 `scanf` 函数. 它的参数形式与 `printf` 相似, 使用几乎相同的格式化指令. 但是在传递参数的时候需要传递 **指针**, 指针的概念将在后续几节课中介绍, 这里我们只需知道, 对着一个变量使用一元的取地址运算符 `&` 可以获取这个变量的地址.

```c
int aInt;
scanf("%d", &aInt); // 从标准输入读取一个 int 类型的值
```

`scanf`中的空格, 换行等 *空白字符* 将匹配 **零个或多个** 空白字符. `scanf` 中的其他普通字符要求在标准输入中严格匹配, 否则 `scanf` 会运行失败.

```c
int x, y;
scanf("(%d,%d)", &x, &y); 
// 如果输入是 (1,4) 可以读取成功
// 如果输入是 (1 ,4) 则读取失败
// 有因为多数格式化指示会自动消耗前面的空白字符
// (1, 4) 是可以读取成功的.
scanf("(%d , %d)", &x, &y); //上述形式都会成功 
```

下面是一个示例程序:

```c
#include <stdio.h>

int main() {
    int x = 0;
    int y = 0;
    int rd;
    while ((rd = scanf(" (%d,%d)", &x, &y)) != EOF) {
        printf("%d numbers have been inputted successfuly\n", rd);
        printf("now x:%d , y:%d\n", x, y);
        int ch;
        while ((ch = getchar()) != '\n')
            ;
    }
    return 0;
}
```

#### A+B problem

这是一道简单的算术题, 要求我们从标准输入读取两个整数, 然后将两个整数的和输出到标准输出.

我们可以编写如下的程序解决该问题:

```c
#include <stdio.h>

int main() {
    int a, b;
    printf("Please input the first integer:");
    scanf(" %d", &a);
    printf("Please input the second integer:");
    scanf(" %d", &b);
    printf("The result is %d", a+b);
    return 0;
}
```

这个程序的运行效果如下:

![1+1](https://hackmd.io/_uploads/rJIwJSVoC.png)

就目前来说, 这已经解决了需求. 接下来我们发来看一下在 **OJ** (在线评测系统) 的 A+B Problem:

[洛谷 P1001](https://www.luogu.com.cn/problem/P1001)

题目描述里明确的提到了对输入/输出格式的要求, 因为在线判题网站往往会将标准输入输出重定向到文件, 以此进行自动化的判题, 所以所有的用于在终端环境下提示性的输出都是没有意义的.

另外还提到了输入的 **数据规模** 的要求:

$$
|a|, |b| \le 10^9
$$

数据规模可以用来评估程序的时间复杂度, 是否会发生溢出等情况: 这里程序只需按需运行一遍, 运行时间不会有明显变化. 是否溢出需要我们判断 $10^9$ 需要多少二进制位表示. 使用对2的对数可以解决

$$
\log_210^9 = \frac{log_{10}10^9}{log_{10}2} \approx 9 \div 0.301 \approx 30
$$

常规情况下 `int` 为 32 位, 所以不会溢出.

#### 小玉买文具

[洛谷P1421](https://www.luogu.com.cn/problem/P1421)

参考程序:

```c++
#include <stdio.h>

int main(void)
{
    long a,b,sum;
    scanf("%ld %ld",&a,&b);
    sum= a*10+b;
    printf("%ld",sum/19);
    return 0;
}
```

### 浮点类型

上文介绍了计算机中整数的表示和简单的使用. 下面介绍 **浮点数** 的表示和计算. 这是一种近似表示 **实数** 的数据类型.

![330px-Float_mantissa_exponent](https://hackmd.io/_uploads/HJCt1qPiR.png)

**浮点数** 是使用类似 *科学计数法* 的方式存储的数字. 比如 $7.9 \times 10^3$, 也可以写成 $7.9 e 3$, 这里 $7.9$ 可以被称为 **有效数** 或 **尾数** , $3$ 可以被称为 **阶码**. <!--愿世界学术名词统一--> 在计算机内部的存储中浮点数也是用存储有效数和指数的形式表示的, 不过使用的基数为2. 

浮点数名字里 **浮点** 一词的含义就是小数点位置 **由指数指定** 的表示方法. 与之相对的概念就是 **定点数**, 小数点位置为提前约定好的固定位置的表示方法, 因为小数点位置固定, 在最简单的情况下定点数可以使用整数类型表示.

#### 浮点数的表示

浮点数格式的常见规范是 [IEEE 754 二进制浮点数算数标准](https://standards.ieee.org/ieee/754/6210/) <!--付款连接.lnk-->. 这里以此标准介绍.

> IEEE 常读作 eye-triple-ee

IEEE 浮点数使用三个部分表示一个浮点数

- 符号位 1位符号
- 尾数 无符号整数
- 阶码 有符号整数

浮点数的长度也具有多种规格. 常见的是 32位 和 64位, 这两个规格分别称为 **单精度** 和 **双精度**. (以此类推, 还有半精度16位, 四精度128位, etc.).

32位浮点数的尾数占用 23 位, 阶码占用 8 位. 64位浮点数尾数占用52位, 阶码占用 11 位.

> 本节剩余部分均为可选

![浮点数布局](https://hackmd.io/_uploads/ryP_Scvo0.png)

接下来介绍上述三个部分的解读方式：

- 符号位为 `1` 时表示负数
- 尾数是一个常规的无符号整数
- 阶码是一个有符号整数, 但是它不是使用补码编码的, 而是使用一种偏置的方式进行编码. 某个位模式表示的有符号整数位对应表示的无符号整数减去一个 **偏移量** , 这个偏移一般为 $2^{k-1}-1$, 这里 $k$ 为阶码的位数. 

根据阶码的不同, IEEE 浮点数有大致可以归类为三种模式

- 阶码位不全为`0` 也不全为 `1` , 为 **常规模式** (翻译对照:*normal*).
- 阶码为全为 `0` 为 **非常规模式**
- 阶码位全为 `1` 为 **特殊值**.

当浮点数是常规模式时, 尾数值 **隐含以 1 开头**, 比如尾数的为 `00101` 那么它应按照 `1.00101` (二进制) 解释. 

当浮点数为非常规模式时, 阶码位模式全为0, 但是会按照数值1解释, 也就是阶码为 `1-偏移量`. 同时位数不再以隐含1开头, 比如 `00101` 应解释为 `0.00101`.

浮点数支持两个特殊值类型, **无穷 INF** 和 **非数 NaN**. 当阶码全为 `1` , 尾数为 `0` 表示无穷, 根据符号位可以分为正无穷和负无穷. 当尾数不是 `0` 表示 *NaN*  (Not a Number), 它表示结果不是实数或者无穷.

这里再额外解释一下非常规数阶码解释为 `1` 的原因: 这样做可以让常规模式和非常规模式的值域平滑连接, 并且不重叠.

这里设阶码偏移为 $Bias$. 最小的常规模式浮点数为阶码原始值为 $1$, 尾数位全为 `0`. 它的值就是 $1.0 \times 2 ^ {1 - (Bias-1)}$.

最大的非常规模式浮点数的阶码固定, 尾数位全为 `1`, 设尾数位数有 $n$ 位. 值为: $(0.111...) \times 2^{1 - (Bias-1)}$.

两者数值只差 $2^{-n} \times 2^{Bias}$.

#### 浮点变量声明

C中支持 `float` 和 `double` 两种浮点数. 一般而言 `float` 配置为单精度浮点数, `double` 配置为双精度浮点数. 还支持 `long double` 作为扩展精度浮点类型, C和C++对这个类型的要求不同, 但是一般来说这个类型的精度不低于 `double`.

浮点数字面量可以使用 `.` 的形式, 也可以使用以 `e` 作为分隔符的科学计数法形式.

```c++
float f1 = 1.2;
double d1 = 0.6;
double v1 = 7.9e3;
```

准确来说浮点字面量的完整形式如下:

```txt
小数点前的数字.小数点后的数字e指数部分
```

但是可以进行一些省略:

```C++;
double value3 = 11.1e2;
double value1 = 1e2;
double value2 = 1.;
double value3 = 1.e2;
double value4 = .1e2;
double value6 = .1;
```

C99支持十六进制浮点数字面量, *C++* 在 *C++17* 之后也支持. 十六进制字面量以 `0x` 开头, 使用 `p` 符号作为指数符号 (因为 `e` 作为十六进制的 14 使用).

```C
float f = 0x1ffp127;
```

浮点字面量的类型为 `double` 后缀 `f`, 和 `l` 可以将其指定为 `float` 或 `long double`.

#### 无法精确表示的特性和舍入方向

因为二进制小数位权重所固有的特性, 二进制小数必然无法精确记录一些实数, 比如 $\frac{1}{10}$, 在十进制中可以表示为 `0.1`, 但是在二进制小数中无法使用有限的小数位表示这个数值, 就像十进制小数无法使用有限的小数位表示 $\frac{1}{3}$ 一样.

因为表示方法限制了浮点数的精度和范围, 所以浮点数只能近似的表示实数运算. **舍入** 运算是用来求某个值在给定精度下 *最接近值* 的运算.

常见的几种舍入方向如下:

- 向偶舍入: 舍入后最低精度位为 `0` 的方式.
- 向零舍入: 整数向下舍入, 负数向上舍入
- 向下舍入: 在给定精度下, 不大于特定值的最大值
- 向上舍入: 在给定精度下, 不小于特定值的最小值

#### 浮点运算

##### 浮点运算符

浮点计算支持常见的 `+`, `-`, `*`, `/`. 取余运算符并不适用于浮点数（但有浮点取余函数）.

所有的浮点运算, 按照IEEE的标准只需给出两个浮点数所代表的 **实数** 的计算结果按照目前 **浮点环境** 指定的舍入方向舍入后的结果即可. 

浮点运算通常由专用的浮点运算硬件进行, 但是对于没有浮点运算硬件的平台, 编译器可能通过软件垫片的方式模拟出浮点计算, 这种情况下浮点运算的代价是巨大的.

这里对于各个浮点运算符不再详细介绍, 只额外说明一下浮点特殊值在运算中的效果. 

`NaN` 表示值的实数意义不存在. 比如无穷减去无穷, 无穷乘以 `0`. 任何数和 `NaN` 进行运算都会得到 `NaN`. 

> [!Tip] Signaling NaN & Quiet NaN
> `NaN` 还有 *安静的非数* (quiet NaN), 和 *发信的非数* (signaling NaN) 两种. 当 *发信的NaN* 用作运算时会触发异常. 但是对于C/C++来说, 默认会忽略因为发信非数引起的信号, 可以通过浮点环境访问浮点计算异常.
> [What is the difference between quiet NaN and signaling NaN?](https://stackoverflow.com/questions/18118408/what-is-the-difference-between-quiet-nan-and-signaling-nan)

`INFINITY` 表示数值无穷大, 具有正负两种, 任何数除以 `0` 都会得到无穷大.

浮点数的计算错误往往不会中止程序, 而是在 [**浮点环境**](https://zh.cppreference.com/w/c/numeric/fenv) 中记录一个异常. 这里不做讲解. 

##### 标准数值计算库

除了几种基础的运算符. 标准数值库中也定义了常用于科学计算中的函数. 使用 `math.h` 头文件可以导入其中常见的一些数学函数, 以及一些浮点数操作所需的常量和功能 (比如提供了 `NAN` 符号表示非数, `INFINITY` 表示无穷).

详细可参考 [常用数学函数](https://zh.cppreference.com/w/c/numeric/math).

这些数学函数的名字大多以名字加一个用于区分类型的后缀组成, 没有特别后缀的操作 `double` 类型. 比如, 函数 `fabs` 是一个求浮点绝对值的函数, 它操作的类型为 `double`, 函数 `fabsf` 作用相同, 但是它操作 `float` 类型, `fabsl` 操作 `long double` 类型.

有些函数不止接受一个参数, 比如 `pow` 第一个参数指定底数, 第二个参数指定幂次. 可仔细阅读相关项目的函数参数部分的介绍.

函数的 **返回值** 直接 作为这个函数调用的值 代回 到表达式语句中.

```c
#include <stdio.h>
#include <math.h>

int main() {
    printf("This is postive float point: %f\n", fabs(-1.));
    return 0;
}
```

> 这里你可能会想到 `printf` 和 `scanf` 的返回值是什么, 或者有没有返回值? 这两个函数都是有返回值的, 不过多数情况下用不到, 在后文中会介绍.

#### 练习

##### 练习前的补充知识

在开始练习之前了解一下浮点数如何使用 `printf` 和 `scanf` 进行输入输出.

浮点数的表示法由小数记法和指数记法(科学计数法). 对应使用 `f` 和 `e` 浮点数格式指示. C99 支持将浮点数格式化为十六进制指数记法, 格式指示使用 `a`. 另外格式指示 `g` 会根据浮点数的值自动选择表示法.

默认格式化的或者使用 `l` 修饰符指定的浮点数类型为 `double` , 使用修饰符 `L` 指定的浮点数类型是 `long double`. 没有 `float` 的格式化输出.

对于 `scanf` 上述几个格式化指示没有区别, `scanf` 都会匹配读取一个浮点数. 但是对于格式化的类型默认情况下指定的是 `float` 类型, `l` 修饰符指定 `double` , `L` 修饰符指定 `long double`.

```C++
float f;
double d;
long double ld;
scanf(" %a %la %La", &f, &d, &ld);

// 虽然printf没有 float 的格式化指示, 
// 但是因为变长实参的默认实参提升  , 这里 f 被转换为了 double 然后传了进去
printf(" %a %la %La", f, d, ld); 
```

另外, 一种在输出时的常见需求是需要指定小数的精确位数, 使用 `.精度` 的修饰符组合可以指定精度. 比如 `%.2f` 这里指精确到两位小数. 这个修饰符必须出现在指定类型的修饰符前.

##### 一元二次方程

考虑一个命令行程序, 它可以求解一元二次方程.

一元二次方程的一般形式如下:

$$
ax^2 + bx + c = 0 (a \ne 0)
$$

我们需要要求用户输入$a$, $b$, $c$ 三个参数.

一元二次方程的实数根的数量不确定, 所以需要使用判别式判定. 对于判别式不同的结果进行不同的计算. 这里需要使用到分支语句 `if`. 语法如下, 括号里的为 `if` 的条件, 如果判定为真, 那么执行if对应的语句, 否则执行else对应的语句. `else` 部分可以省略. 语句经常使用 **复合语句**, 这样一个 `{}` 包围的语句列表, 用于在语法上接受一个语句的地方塞入多个语句. `if` 语句将在控制流部分详细介绍.

这里条件判断需要一些 **条件运算符** :

- `<` 小于
- `<=` 小于等于
- `==` 等于
- `>` 大于
- `>=` 大于等于
- `!=` 不等于

详细的表达式相关的内容将在下节课讲解.

```c
if (cond)
    stmt;
else
    stmt;

```

示例程序:

```c
#include <stdio.h>
#include <math.h>


int main() {
    double a, b, c;
    printf("Argument a:");
    scanf("%lf", &a);
    printf("Argument b:");
    scanf("%lf", &b);
    printf("Argument c:");
    scanf("%lf", &c);
    
    auto delta = b*b - 4*a*c;
    if (delta < 0) {
        printf("The equation don't have real root\n");
    } else if (delta == 0) { // if 的 else 部分写了一个 if语句
        printf("The only real root is %lg\n", (-b+sqrt(delta))/(2*a));
    } else {
        auto root1 = (-b+sqrt(delta))/(2*a);
        auto root2 = (-b-sqrt(delta))/(2*a);
        printf("roots: %lg %lg", root1, root2);
    }
    
    return 0;
}
```

##### 账目求和

这里我们编写一个使用命令行在标准输出输出交互的账目求和程序。这里货币我们仅支持人民币一种。

交互的格式可任意，这里我们选择接受从标准输入读取多个单位为 **元** 的数据， 但是我们并不能使用浮点数. 因为前面提到过, 浮点数的误差和表示法固有的特性使得精确度在金融计算里无法接受. 下面是一个能够表现浮点数精确度方面问题的示例.

```C++#include <stdio.h>
#include <math.h>
#include <limits>
#include <iostream>

int main() {
	// round-off error 1
    printf("This is a positive floating-point number: 0.1 ~> %.17f <- 👀\n", 0.1);
	
	// round-off error 2
	if (0.1 + 0.2 == 0.3) {
        puts("0.1 + 0.2 equal😋 0.3");
    } else {
		printf("not equal😡! %.17f != %.17f\n", 0.1 + 0.2, 0.3);
	}
	
	// machine epsilon
    std::cout << "machine epsilon: " << std::numeric_limits<double>::epsilon() <<std::endl;
    return 0;
}
```
输出：
```
This is a positive floating-point number: 0.1 ~> 0.10000000000000001 <- 👀
not equal😡! 0.30000000000000004 != 0.29999999999999999
machine epsilon: 2.22045e-16
```

[Why not use Double or Float to represent currency?](https://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency).

所以我们这里选择使用定点数, 也就是整数存储和处理.

> [!Note] 定点数支持
> Clang（-ffixed-point）和 GCC（部分平台） [支持](https://gcc.gnu.org/onlinedocs/gcc/Fixed-Point.html)定点数哟

> [!Tip] 十进制浮点数
> 这里选择所谓的十进制浮点数（IEEE-854 基数无关的浮点算数标准）, 可能是更好的选择, 但是C++本身不支持, C在早期版本也不支持 (C23加入了 `_Declimal64` 等类型, 但是 是可选特性.) . 所里这里不介绍

示例代码:

```c++
#include <stdio.h>
#include <ctype.h>

/**
 * @brief 从标准输入用于读取一个以元为单位的货币，并以分为单位写入target. 最多支持两位小数
 * @param target 数值写入的位置。
 * @return 函数正常执行返回 0， 否则返回 EOF
 */
                        
int input_money(int &target) {
    int buf;

    target = 0;

    bool negative = false;

    // 处理字面量中的符号
    if ((buf = getchar()) == EOF) {
        return EOF;
    }
    if (buf == '-' || buf == '+') {
        negative = true;
    } else if (buf != '+') {
        ungetc(buf, stdin);
    }

    // 读取并处理第一部分
    // scanf 会返回读取的条目的数量，当第一个格式化输入 **之前** 就出现错误，
    // 或者已经到达文件结尾等错误则返回 EOF
    if (scanf(" %d", &buf) != 1) {
        return EOF;
    }
    target += 100 * buf;
    
    // 处理第二部分
    if ((buf = getchar()) == '.') {
        // 剩下最多读取两个数字
        int tmp = 0;
        if ((buf = getchar()) != EOF) {
            if (isdigit(buf)) { 
                // 小数点后一位

                // 根据 ASCII 码位的排列特点，
                // 各个数字字符的编码值与 `0` 字符的编码值的差与数值相等.
                tmp += (buf - '0') * 10; 
                if ((buf = getchar()) != EOF) {
                    if (isdigit(buf)) {
                        // 小数点后两位
                        tmp += buf - '0';
                    } else {
                        // 退回这个不是数字的字符给标准输入
                        ungetc(buf, stdin);
                    }
                }
            } else {
                ungetc(buf, stdin); 
            }
        }
        target += tmp;
    } else {
        // 没有小数点， 没有第二部分
        ungetc(buf, stdin);
    }

    if (negative) {
        target = -target;
    }

    return 0;
}

/**
 * @brief 按照元为单位输出给定的金额
 * @param money 待输出的金额, 以分为单位
 */
void output_money(int money) {
    printf("%d", money/100);
    if (money % 100) {
        auto remain = money%100;
        remain = (remain >= 0 ? remain : -remain);
        printf(".%d", remain);
    }
}

int main() {
    int total_money = 0;

    int buf;
    while (input_money(buf) != EOF) {
        total_money += buf;
    }
    output_money(total_money);
}
```

这组代码里使用了非常多未介绍的特性. 简单了解即可.

**注释** 是一些内容不具语法功能的文本, 用于提供给编程人员阅读代码时辅助使用. C/C++ 支持的注释有两种:

```c++
/* 多行注释, 在 `/*` 和 `*/ /*之间的都是注释
*/ 

// 单行注释, 从 `//` 标记到逻辑行尾的内容都是注释, C在C99后支持
```

> [!Note] 将代码无效
> 您可以使用注释临时使代码失效，编辑器一般会使用 `Ctrl+/` 快捷键将当前选区注释取消注释.
> 通过将代码注释可以将目前不需要的代码暂时保留在文件中, 而不是将他删除. 将大片代码进行注释时可能需要注意下文提到的 **块注释嵌套** 问题. 所以一般使用单行注释, 也可以用 **预处理器** 达到类似的效果.
> ```c
> #if 0
>     1+1;
> #endif
> ```

标准认为 `/* */` 注释不支持嵌套, 注释一旦到 `*/` 就会立刻结束(所以上面注释示例在一个很奇怪的位置有一个 `/*`), 但是历史上存在支持嵌套块注释的编译器. 下面这有趣的代码 [^1] 可以检测编译器是否支持嵌套注释, 它在不支持嵌套注释的情况下求值为 `0`, 支持的情况下求值为 `1`.

```C++
/*/*/0*/**/1
```

> [!note] 受注释控制的辅助工具
> 虽然 **注释内容** 在语言中不具语法功能，但是代码辅助工具可以读取注释内容, 比如程序静态分析器 (过去被称为 [`lint` 程序](https://zh.wikipedia.org/wiki/Lint)), 可以读取特定格式的注释进而禁用或启用某些检查类别.
>
> 上文中注释使用了 [*Doxygen*](https://www.doxygen.nl/) 工具的一种注释格式  (但是准确来说上文中的语法来自 `javadoc`[^2]) . 这是一种可以生成代码文档的工具, 但是这里并不详细讲解, 只知道名字即可. 现代 IDE 可以读取文档注释, 并在自动补全或悬浮提示时,给出文档提示.

另外上面程序还使用了循环语句 `while` , 它和 `if` 的语法相似, 不过没有 `else` 部分, 当它的条件为真, 就执行一次它的循环体, 直到条件为假, 每次循环体执行前都会判断一次条件. 详细内容将在 **控制流** 相关内容时讲解.

上文还声明了 `main` 函数以外的函数: `input_money` 和 `ouput_money`. 函数声明的语法也会在 **控制流** 相关内容时讲解.   
这里只需了解, `input_money` 接受一个 `int` 类型的 **引用** (引用是一种C++类型, 将在后续复合类型时讲解), 返回一个 `int` 类型的值表示是否调用成功, 详细的作用可以阅读代码中的注释.   
`ouput_money` 接受一个 `int` 类型的值, 不返回值 (`void` 类型表示空, 多数情况用于占位, 不能直接用来声明变量).

对于C来说, 所有函数都是所谓的 **传值调用**. 意思为当一个变量作为函数的实参传递给函数时, 函数得到的只是一个该变量的副本, 该函数对它的形参变量的任何操作都不会直接反应到实参上.   
这里使用了C++的引用类型, 使得函数可以修改实参. 详细内容将在接受函数时介绍.

代码出现了符号 `EOF` 意思是文件结尾 _**E**nd **o**f **F**ile_.  
输入函数当前读取的文件到达文件结尾或出现某些错误时可能会返回这个值.  
这个值由 `stdio.h` 提供, 对于大多数环境是 `-1`.   
另外对于命令行程序, 标准输入默认绑定到终端输入, 这意味着我们概念上这个文件会随着我们输入增长我们不可能真正的读到文件结尾.  
详细的终端输入时的默认行为将在文件IO时介绍  
通过组合键 `Ctrl-Z` (Windows cmd 和 PowerShell), 或 `Ctrl-D` (Linux和其他类Unix系统), 可以给终端发送一个 `EOF`.

[^1]: 《C陷阱与缺陷》 练习1-1.
[^2]: 待考证. 暂时找不到更早的了.

##### 三角形面积 <!--无讲解-->

这是一道 OI 题. 

[洛谷P5708](https://www.luogu.com.cn/problem/P5708).

题目中提到了精度要求. 输出时可以使用 `printf` 的 `.精度` 修饰符适当的指定精度. 